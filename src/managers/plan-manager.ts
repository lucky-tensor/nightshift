/**
 * Plan Manager
 *
 * Manages implementation plans for products. A plan contains:
 * - Overview and goals
 * - Milestones
 * - Ordered list of projects
 * - Dependencies between projects
 *
 * Plans are generated by the planner agent and stored both:
 * - In YAML storage (structured data)
 * - In PLAN.md (markdown documentation)
 */

import { v4 as uuid } from "uuid";
import { writeFileSync } from "fs";
import { getStorage } from "../storage/yaml";
import { ProductManager } from "./product-manager";
import type { Plan, PlannedProject, Milestone } from "../types";
import { logInfo, logSuccess, logDim } from "../utils/helpers";

export class PlanManager {
    private productManager: ProductManager;

    constructor() {
        this.productManager = new ProductManager();
    }

    /**
     * Create a new plan for a product
     *
     * This is typically called after the PRD is generated.
     * The plan structure is provided (usually from a planner agent).
     *
     * @param productId - Product UUID
     * @param planData - Plan content (overview, goals, projects)
     * @returns The created plan
     *
     * @example
     * ```typescript
     * const pm = new PlanManager();
     * const plan = await pm.createPlan(productId, {
     *   overview: "Build task manager in 3 phases",
     *   goals: ["User auth", "Task CRUD", "Sharing"],
     *   projects: [...]
     * });
     * ```
     */
    async createPlan(
        productId: string,
        planData: {
            overview: string;
            goals: string[];
            milestones?: Milestone[];
            projects: Omit<PlannedProject, "id" | "status">[];
        }
    ): Promise<Plan> {
        const product = this.productManager.getProduct(productId);
        if (!product) {
            throw new Error(`Product not found: ${productId}`);
        }

        logInfo(`[Plan] Creating implementation plan...`);

        const storage = getStorage();

        // Generate project IDs and set initial status
        const projects: PlannedProject[] = planData.projects.map((p) => ({
            id: uuid(),
            ...p,
            status: "pending",
        }));

        // Update project status based on dependencies
        this.updateProjectStatuses(projects);

        const plan: Plan = {
            productId,
            version: 1,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            overview: planData.overview,
            goals: planData.goals,
            milestones: planData.milestones || [],
            projects,
        };

        // Save to storage
        storage.plan(productId).savePlan(plan);

        // Update product metrics
        this.productManager.updateProduct(productId, {
            totalProjects: projects.length,
            status: "in_progress",
        });

        // Generate PLAN.md
        await this.generatePlanMarkdown(product.planPath, plan);

        logSuccess(`[Plan] ‚úì Plan created with ${projects.length} projects`);

        return plan;
    }

    /**
     * Get the plan for a product
     *
     * @param productId - Product UUID
     * @returns Plan or undefined
     */
    getPlan(productId: string): Plan | undefined {
        const storage = getStorage();
        return storage.plan(productId).getPlan();
    }

    /**
     * Get the next executable project
     *
     * Returns the highest priority project that:
     * - Is in "ready" status (dependencies met)
     * - Has no dependencies or all dependencies are completed
     *
     * @param productId - Product UUID
     * @returns Next project to execute or undefined
     */
    getNextProject(productId: string): PlannedProject | undefined {
        const plan = this.getPlan(productId);
        if (!plan) return undefined;

        // Get all ready projects
        const readyProjects = plan.projects.filter((p) => p.status === "ready");

        if (readyProjects.length === 0) return undefined;

        // Sort by priority (1 = highest)
        readyProjects.sort((a, b) => a.priority - b.priority);

        return readyProjects[0];
    }

    /**
     * Mark a project as in progress
     *
     * @param productId - Product UUID
     * @param projectId - Project ID from plan
     */
    markProjectInProgress(productId: string, projectId: string): void {
        const plan = this.getPlan(productId);
        if (!plan) {
            throw new Error(`Plan not found for product: ${productId}`);
        }

        const projectIndex = plan.projects.findIndex((p) => p.id === projectId);
        if (projectIndex === -1) {
            throw new Error(`Project not found in plan: ${projectId}`);
        }

        const project = plan.projects[projectIndex];
        if (!project) {
            throw new Error(`Project not found in plan: ${projectId}`);
        }

        project.status = "in_progress";

        const storage = getStorage();
        storage.plan(productId).savePlan(plan);

        logInfo(`[Plan] Project "${project.name}" started`);
    }

    /**
     * Mark a project as completed
     *
     * Updates project status and recalculates which projects become ready.
     *
     * @param productId - Product UUID
     * @param projectId - Project ID from plan
     */
    markProjectCompleted(productId: string, projectId: string): void {
        const plan = this.getPlan(productId);
        if (!plan) {
            throw new Error(`Plan not found for product: ${productId}`);
        }

        const projectIndex = plan.projects.findIndex((p) => p.id === projectId);
        if (projectIndex === -1) {
            throw new Error(`Project not found in plan: ${projectId}`);
        }

        const project = plan.projects[projectIndex];
        if (!project) {
            throw new Error(`Project not found in plan: ${projectId}`);
        }

        project.status = "completed";

        // Update dependent projects
        this.updateProjectStatuses(plan.projects);

        // Check if all projects are done
        const allCompleted = plan.projects.every((p) => p.status === "completed");

        const storage = getStorage();
        storage.plan(productId).savePlan(plan);

        // Update product
        this.productManager.recordProjectCompleted(productId);

        if (allCompleted) {
            this.productManager.updateProduct(productId, {
                status: "review",
            });
            logSuccess(`[Plan] ‚úì All projects completed! Product ready for review.`);
        } else {
            logSuccess(`[Plan] ‚úì Project "${project.name}" completed`);
        }
    }

    /**
     * Update project statuses based on dependencies
     *
     * Sets projects to "ready" if all dependencies are completed,
     * or "blocked" if dependencies are not met.
     *
     * @param projects - Array of projects to update
     */
    private updateProjectStatuses(projects: PlannedProject[]): void {
        const completedIds = new Set(
            projects.filter((p) => p.status === "completed").map((p) => p.id)
        );

        for (const project of projects) {
            if (project.status === "completed" || project.status === "in_progress") {
                continue;
            }

            // Check if all dependencies are met
            const dependenciesMet = project.dependencies.every((depId) => completedIds.has(depId));

            if (dependenciesMet) {
                project.status = "ready";
            } else {
                project.status = "blocked";
            }
        }
    }

    /**
     * Generate PLAN.md markdown file
     *
     * Creates a human-readable plan document in the product repository.
     *
     * @param planPath - Absolute path to PLAN.md
     * @param plan - Plan object
     */
    private async generatePlanMarkdown(planPath: string, plan: Plan): Promise<void> {
        let markdown = `# Implementation Plan\n\n`;

        markdown += `**Version**: ${plan.version}  \n`;
        markdown += `**Created**: ${new Date(plan.createdAt).toLocaleDateString()}  \n`;
        markdown += `**Updated**: ${new Date(plan.updatedAt).toLocaleDateString()}  \n\n`;

        markdown += `## Overview\n\n${plan.overview}\n\n`;

        markdown += `## Goals\n\n`;
        for (const goal of plan.goals) {
            markdown += `- ${goal}\n`;
        }
        markdown += `\n`;

        if (plan.milestones.length > 0) {
            markdown += `## Milestones\n\n`;
            for (const milestone of plan.milestones) {
                markdown += `### ${milestone.name}\n\n`;
                markdown += `${milestone.description}\n\n`;
                if (milestone.targetDate) {
                    markdown += `**Target**: ${new Date(milestone.targetDate).toLocaleDateString()}\n\n`;
                }
            }
        }

        markdown += `## Projects\n\n`;
        markdown += `Total: ${plan.projects.length} | Completed: ${plan.projects.filter((p) => p.status === "completed").length}\n\n`;

        for (const project of plan.projects) {
            const statusEmoji = this.getStatusEmoji(project.status);
            markdown += `### ${statusEmoji} ${project.name}\n\n`;
            markdown += `**Status**: ${project.status}  \n`;
            markdown += `**Priority**: ${project.priority}  \n`;
            markdown += `**Estimated**: ${project.estimatedDays} days  \n`;

            if (project.dependencies.length > 0) {
                const depNames = project.dependencies
                    .map((depId) => {
                        const dep = plan.projects.find((p) => p.id === depId);
                        return dep ? dep.name : depId;
                    })
                    .join(", ");
                markdown += `**Dependencies**: ${depNames}  \n`;
            }

            markdown += `\n${project.description}\n\n`;

            // Show assigned agents
            const agents: string[] = [];
            if (project.plannerAgent) agents.push("Planner");
            if (project.coderAgent) agents.push("Coder");
            if (project.curatorAgent) agents.push("Curator");
            if (agents.length > 0) {
                markdown += `**Agents**: ${agents.join(", ")}\n\n`;
            }

            markdown += `---\n\n`;
        }

        markdown += `\n*Generated by Dark Factory*\n`;

        writeFileSync(planPath, markdown, "utf-8");
        logDim(`[Plan] PLAN.md written to ${planPath}`);
    }

    /**
     * Get status emoji for a project
     */
    private getStatusEmoji(status: PlannedProject["status"]): string {
        const emojiMap = {
            pending: "‚è≥",
            ready: "‚úÖ",
            in_progress: "üöß",
            completed: "‚úîÔ∏è",
            blocked: "üö´",
        };
        return emojiMap[status] || "‚ùì";
    }

    /**
     * Update plan (bump version)
     *
     * @param productId - Product UUID
     * @param updates - Partial plan updates
     * @returns Updated plan
     */
    updatePlan(productId: string, updates: Partial<Plan>): Plan {
        const storage = getStorage();
        const updated = storage.plan(productId).updatePlan(updates);

        if (!updated) {
            throw new Error(`Plan not found for product: ${productId}`);
        }

        // Regenerate PLAN.md
        const product = this.productManager.getProduct(productId);
        if (product) {
            this.generatePlanMarkdown(product.planPath, updated);
        }

        return updated;
    }

    /**
     * Get plan progress summary
     *
     * @param productId - Product UUID
     * @returns Progress statistics
     */
    getProgress(productId: string): {
        total: number;
        completed: number;
        inProgress: number;
        ready: number;
        blocked: number;
        percentComplete: number;
    } {
        const plan = this.getPlan(productId);
        if (!plan) {
            throw new Error(`Plan not found for product: ${productId}`);
        }

        const total = plan.projects.length;
        const completed = plan.projects.filter((p) => p.status === "completed").length;
        const inProgress = plan.projects.filter((p) => p.status === "in_progress").length;
        const ready = plan.projects.filter((p) => p.status === "ready").length;
        const blocked = plan.projects.filter((p) => p.status === "blocked").length;

        return {
            total,
            completed,
            inProgress,
            ready,
            blocked,
            percentComplete: total > 0 ? Math.round((completed / total) * 100) : 0,
        };
    }
}
